{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"cpp": {
		"prefix": "cpp",
		"body": [
			"#include <bits/stdc++.h>",
			"#define _GLIBCXX_DEBUG",
			"using namespace std;",
			"typedef long long ll;",
			"typedef long double ld;",
			"const long long INF = 1LL << 60;",
			"const int inf = (1 << 30);",
			"const ll mod = 998244353;",
			"const ll MOD = 1000000007;",
			"const ld PI = acos(-1.0L);",
			"int dy[] = {1, 0, -1, 0}, dx[] = {0, -1, 0, 1};",
			"int dy8[] = {1, 1, 0, -1, -1, -1, 0, 1}, dx8[] = {0, -1, -1, -1, 0, 1, 1, 1};",
			"template<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }",
			"template<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }",
			"using lll = __int128_t;"
		],
		"description": "cpp"
	},
	  "is_prime":{
		"prefix": "is_prime",
		"body": [
			"bool is_prime(ll num){",
			"\tif(num==1) return false;",
			"\tfor(ll i=2;i*i<=num;++i){",
			"\t\tif(num%i==0) return false;",
			"\t}",
			"\treturn true;",
			"}"
	],
	},
	"GCD":{
		"prefix": "GCD",
		"body": [
			"long long GCD(long long a, long long b) {",
			"\tif (b == 0) return a;",
			"\telse return GCD(b, a % b);",
			"}"
		],
	},
	"isOK":{
		"prefix": "isOK",
		"body": [
			"bool isOK(ll index, ll key, vector<ll> &data){",
			"\tif(data[index] >= key){",
			"\t\treturn true;",
			"\t}",
			"\telse return false;",
			"}"
		],
	},
	"binary_search":{
		"prefix": "binary_search",
		"body": [
			"ll binary_search(ll key, vector<ll> &data) {",
			"\tll ng = -1; //「index = 0」が条件を満たすこともあるので、初期値は -1",
			"\tll ok = (ll)data.size(); // 「index = a.size()-1」が条件を満たさないこともあるので、初期値は a.size()",
			"\t/* ok と ng のどちらが大きいかわからないことを考慮 */",
			"\twhile (abs(ok - ng) > 1) {",
			"\tll mid = (ok + ng) / 2;",
			"\tif (isOK(mid, key, data)) ok = mid;",
			"\t\telse ng = mid;",
			"\t}",
			"\treturn ok;",
			"}"
		],
	},
	"setprecision":{
		"prefix": "setprecision",
		"body": [
			"cout << std::fixed << std::setprecision(15) ;",
		],
	},
	"section":{
		"prefix": "section",
		"body": [
			"// 区間分割する",
			"int i=0;",
			"while (i < N) {",
			"\tif (h[i] == 0) ++i; // 0 なら何もせずに次に進む",
			"\t\telse {",
			"\t\t++res; // 区間の始まり",
			"\t\twhile (i < N && h[i] > 0) {",
			"\t\t\t//ここに処理を書くh[i]--;",
			"\t\t\t++i; // 区間の終わりまで一気に",
			"\t\t}",
			"\t}",
			"}"	,	
		],
	},
	"aizuonline":{
		"prefix": "aizuonline",
		"body": [
			"#include <bits/stdc++.h>",
			"#define _GLIBCXX_DEBUG",
			"using namespace std;",
			"typedef long long ll;",
			"typedef long double ld;",
			"const long long INF = 1LL << 60;",
			"const ll mod = 998244353;",
		],
	},
	"From_k_To_l": {
		"prefix": "From_k_To_l",
		"body": [
			"string From_k_To_l (string num, int k,int l){",
			"    // k進数をl進数に変換する関数",
			"    // ただし 1 <= k <= 10 && 1 <= l << 10 ",
			"    ll tmp = 0;",
			"    int cnt = 0;",
			"    for(int i=(int)num.size()-1;i>=0;i--){",
			"        tmp +=  (num[i]-'0') * (ll)pow(k,cnt);",
			"        cnt++;",
			"    }",
			"    // 10進数になった。",
			"    if(tmp == 0) return \"0\";",
			"    string res;",
			"    while(tmp){",
			"        res = to_string(tmp%l) + res;",
			"        tmp /= l;",
			"    }",
			"    return res;",
			"}"
		],
		"description": "From_k_To_l"
	},
	"prime_factorize": {
		"prefix": "prime_factorize",
		"body": [
			"// 素因数分解する関数",
			"vector<pair<ll,ll>> prime_factorize(ll N){",
			"    vector<pair<ll,ll>>res;",
			"    for(ll i=2;i*i <= N;i++){",
			"        if(N % i != 0) continue;",
			"        ll num = 0;",
			"        while(N % i == 0){",
			"            num++;",
			"            N /= i;// これで素数だけが取れる",
			"        }",
			"        res.push_back({i,num});",
			"    }",
			"    if(N != 1) res.push_back({N,1});//素数の時",
			"    return res;",
			"}"
		],
		"description": ""
		},
	"combination": {
		"prefix": "combination",
		"body": [
			"// combination の高速計算",
			"// 詳細は https://drken1215.hatenablog.com/entry/2018/06/08/210000",
			"const int MAX = 510000;",
			"const int MOD = 1000000007;",
			"",
			"long long fac[MAX], finv[MAX], inv[MAX];",
			"",
			"// テーブルを作る前処理",
			"void COMinit() {",
			"    fac[0] = fac[1] = 1;",
			"    finv[0] = finv[1] = 1;",
			"    inv[1] = 1;",
			"    for (int i = 2; i < MAX; i++){",
			"        fac[i] = fac[i - 1] * i % MOD;",
			"        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;",
			"        finv[i] = finv[i - 1] * inv[i] % MOD;",
			"    }",
			"}",
			"",
			"// 二項係数計算",
			"long long COM(int n, int k){",
			"    if (n < k) return 0;",
			"    if (n < 0 || k < 0) return 0;",
			"    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;",
			"}",
			"",
			"int main() {",
			"    // 前処理",
			"    COMinit();",
			"",
			"    // 計算例",
			"    cout << COM(100000, 50000) << endl;",
			"}"
		],
		"description": ""
	},
	"LCM": {
		"prefix": "LCM",
		"body": [
			"/* a と b の最小公倍数を求める */",
			"long long LCM(long long a, long long b) {",
			"    long long g = GCD(a, b);",
			"    return a / g * b;",
			"}"
		],
		"description": ""
	},
	"compress": {
		"prefix": "compress",
		"body": [
			"vector<ll> compress(vector<ll> &X){",
			"    vector<ll> vals = X;",
			"    sort(vals.begin(), vals.end());",
			"    // 下記の操作で重複を削除",
			"    vals.erase(unique(vals.begin(),vals.end()),vals.end());",
			"    for(int i=0;i<X.size();i++){",
			"        X[i] = ( lower_bound(vals.begin(),vals.end(),X[i]) - vals.begin() );",
			"    }",
			"    return vals;",
			"}"
		],
		"description": "1次元の座標圧縮"
	},
	"digitsum": {
		"prefix": "digitsum",
		"body": [
			"int digsum(int n) {",
			"    int res = 0;",
			"    while(n > 0) {",
			"        res += n%10;",
			"        n /= 10;",
			"    }",
			"    return res;",
			"}"
		],
		"description": ""
	},
	"mod_pow": {
		"prefix": "mod_pow",
		"body": [
			"// xのn乗%modを計算",
			"long long mod_pow(long long x, long long n, long long mod){",
			"    long long res = 1;",
			"    while(n > 0){",
			"        if(n & 1) res = res*x%mod;",
			"        x = x*x%mod;",
			"        n >>= 1;",
			"    }",
			"    return res;",
			"}"
		],
		"description": ""
	},
	"string_count": {
		"prefix": "string_count",
		"body": [
			"// string sのなかにある char cの数を数える関数",
			"int string_count(string s, char c) {",
			"    return count(s.cbegin(), s.cend(), c);",
			"}"
		],
		"description": ""
	},
	"atcoder": {
		"prefix": "atcoder",
		"body": [
			"#include <bits/stdc++.h>",
			"#include <atcoder/all>",
			"#define _GLIBCXX_DEBUG",
			"using namespace std;",
			"using namespace atcoder;",
			"typedef long long ll;",
			"typedef long double ld;",
			"const long long INF = 1LL << 60;",
			"const int inf = (1 << 30);",
			"const ll mod = 998244353;",
			"const ll MOD = 1000000007;",
			"const ld PI = acos(-1.0L);",
			"int dy[] = {1, 0, -1, 0}, dx[] = {0, -1, 0, 1};",
			"int dy8[] = {1, 1, 0, -1, -1, -1, 0, 1}, dx8[] = {0, -1, -1, -1, 0, 1, 1, 1};",
			"template<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }",
			"template<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }",
			""
		],
		"description": ""
	},
	"Edge": {
		"prefix": "Edge",
		"body": [
			"struct edge {",
			"    int from; int to; ll w;",
			"    edge(int from, int to, ll w) : from(from), to(to), w(w) {}",
			"};"
		],
		"description": ""
	},
	"Binary-Indexed-Tree": {
		"prefix": "BIT",
		"body": [
			"template <class Abel> struct BIT {",
			"    const Abel UNITY_SUM = 0;// ここで初期値を決定する",
			"    vector<Abel> dat;",
			"    ",
			"    /* [1, n] */",
			"    BIT(int n) : dat(n + 1, UNITY_SUM) { }",
			"    void init(int n) { dat.assign(n + 1, UNITY_SUM); }",
			"    ",
			"    /* a is 1-indexed */",
			"    inline void add(int a, Abel x) {",
			"        for (int i = a; i < (int)dat.size(); i += i & -i){",
			"            dat[i] = dat[i] + x;",
			"        }",
			"    }",
			"    ",
			"    /* [1, a], a is 1-indexed */",
			"    inline Abel sum(int a) {",
			"        Abel res = UNITY_SUM;",
			"        for (int i = a; i > 0; i -= i & -i)",
			"            res = res + dat[i];",
			"        return res;",
			"    }",
			"    ",
			"    /* [a, b), a and b are 1-indexed */",
			"    inline Abel sum(int a, int b) {",
			"        return sum(b - 1) - sum(a - 1);",
			"    }// 区間和",
			"    ",
			"    /* debug */",
			"    void print() {",
			"        for (int i = 1; i < (int)dat.size(); ++i) cout << sum(i, i + 1) << \",\";",
			"        cout << endl;",
			"    }",
			"};"
		],
		"description": "Binary-Indexed-Tree"
	},
	"matrix": {
		"prefix": "matrix",
		"body": [
			"// 行列計算のためのテンプレート",
			"// 行列の掛け算",
			"template <typename T>",
			"vector<vector<T>> matrix_mult(vector<vector<T>> &A, vector<vector<T>> &B){",
			"    vector<vector<T>> res((int)A.size(),vector<T>((int)B[0].size()));//返値",
			"    for(int i=0;i<(int)A.size();i++){",
			"        for(int k=0;k<(int)B.size();k++){",
			"            for(int j=0;j<(int)B[0].size();j++){",
			"                res[i][j] += A[i][k] * B[k][j];// MODが必要な場合はここに追加 ",
			"            }",
			"        }",
			"    }",
			"    return res;",
			"}",
			"",
			"// 行列の冪乗",
			"// A^nを計算",
			"template <typename T>",
			"vector<vector<T>> matrix_pow(vector<vector<T>> &A, ll n){",
			"    vector<vector<T>> res((int)A.size(),vector<T>((int)A.size()));",
			"    // 冪乗できるので当然正方行列",
			"    for(int i=0;i<(int)A.size();i++){",
			"        res[i][i] = 1;",
			"    }// 単位行列をつくる",
			"    while(n>0){",
			"        if(n & 1) res = matrix_mult(res,A);",
			"        A = matrix_mult(A,A);",
			"        n = (n >> 1);",
			"    }// 繰り返し二乗法を用いているので計算量 0(log(N) * A.size()^3)",
			"    return res;",
			"}"
		],
		"description": "matrix"
	},
	"CumulativeSum2D": {
		"prefix": "CumulativeSum2D",
		"body": [
			"// verified https://atcoder.jp/contests/typical90/tasks/typical90_cc",
			"class CumulativeSum2D {",
			"    private:",
			"        vector<vector<ll>> data;",
			"        bool needToBeBuilt = true;",
			"    public:",
			"        // constructer",
			"        CumulativeSum2D(int H, int W) : data(H+1,vector<ll>(W+1,0LL)) {}",
			"        void add(int h, int w, ll z=1){// default arg = 1LL",
			"            // h and w are 0-index",
			"            h++; w++;",
			"            if(h>=(int)data.size() || w>=(int)data[0].size() || h<0 || w<0) assert(0 && \"error: index is out of range\");",
			"            //枠外アクセスを禁止",
			"            data[h][w]+=z;",
			"        }",
			"        void build(){",
			"            // 計算量 O(HW) 二次元累積和を構築",
			"            for(int i=1;i<(int)data.size();i++) for(int j=1;j<(int)data[0].size();j++){",
			"                data[i][j] += data[i][j-1] + data[i-1][j] - data[i-1][j-1];",
			"            }",
			"            needToBeBuilt = false;",
			"        }",
			"        ll query(int sy, int sx, int gy, int gx){",
			"            // 正方形としては (sy,sx)が左上、(gy,gx)が右下の範囲の累積和",
			"            // sy,sxは、開始座標点を0-indexで、gy,gxは、1-indexで用いる",
			"            if(needToBeBuilt) assert(0 && \"error: please call build()\");",
			"            return(data[gy][gx] - data[gy][sx] - data[sy][gx] + data[sy][sx]);",
			"        }",
			"};"
		],
		"description": "CumulativeSum2D"
	},
	"UnionFind": {
		"prefix": "UnionFind",
		"body": [
			"// verified https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/1/DSL_1_A",
			"// verified siz member function  https://atcoder.jp/contests/abc157/tasks/abc157_d",
			"template<typename T>",
			"class UnionFind {",
			"    private:",
			"        vector<T>par, siz, depth;// 親ノード、要素数、深さ",
			"        void init(T N){",
			"            par.assign(N,-1); siz.assign(N,1); depth.assign(N,1);",
			"        }",
			"    public:",
			"        UnionFind(T N) { init(N); }",
			"        T root(T x){// 根を求める",
			"            if(par[x]==-1) return x;",
			"            else return par[x] = root(par[x]);// 経路圧縮",
			"        }",
			"        bool issame(T x,T y){",
			"            return root(x)==root(y);",
			"        }",
			"        bool unite(T x, T y){",
			"            x = root(x), y = root(y);// x,yの値まで移動する",
			"            if(x==y) return false;",
			"            if(depth[x]<depth[y]) swap(x,y);// 常にxの方が深い",
			"            if(depth[x]==depth[y]) depth[x]++;",
			"            par[y] = x; siz[x] += siz[y];",
			"            return true;",
			"        }",
			"        T size(T x){",
			"            return siz[root(x)];// xを含むグループのサイズ",
			"        }",
			"        T deep(ll x){",
			"            return depth[root(x)];",
			"        }",
			"};"
		],
		"description": "UnionFind"
	},
	"below_bound": {
		"prefix": "below_bound",
		"body": [
			"bool check(ll mid,vector<ll>&v,ll x){",
			"    if(v[mid] <= x) return true;",
			"    else return false;",
			"}",
			"template<typename T>",
			"int below_bound(vector<T>&vec,T value){",
			"    // value以下になるもので最大のidを取得する(0-index)",
			"    int ok = -1; int ng = (int)vec.size();",
			"    while(abs(ok-ng)>1){",
			"        int mid = (ok+ng)/2;",
			"        if(check(mid,vec,value)) ok = mid;",
			"        else ng = mid;",
			"    }",
			"    return ok;// 1つもない時は-1を返す",
			"}"
		],
		"description": "below_bound"
	},
}